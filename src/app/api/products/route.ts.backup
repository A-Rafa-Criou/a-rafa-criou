import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';
import {
  products,
  categories,
  productVariations,
  productImages,
  variationAttributeValues,
  attributes,
  attributeValues,
  productI18n,
  categoryI18n,
  promotions,
} from '@/lib/db/schema';

// üî• OTIMIZA√á√ÉO CR√çTICA: Cache MUITO mais longo
export const revalidate = 7200; // 2 horas (antes era 1 hora)
export const dynamic = 'force-dynamic';

import { eq, inArray, desc, or, and, asc, ilike, sql, gte, lte } from 'drizzle-orm';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = Math.min(parseInt(searchParams.get('limite') || searchParams.get('limit') || '12'), 50); // üî• Limite m√°ximo de 50

    // Suportar tanto offset direto quanto p√°gina
    let offset: number;
    const offsetParam = searchParams.get('offset');
    if (offsetParam !== null) {
      offset = parseInt(offsetParam);
    } else {
      const page = parseInt(searchParams.get('pagina') || '1');
      offset = (page - 1) * limit;
    }

    const featured = searchParams.get('featured') === 'true';
    const searchQuery = searchParams.get('q') || searchParams.get('search') || '';
    const categorySlug = searchParams.get('categoria');
    const sortBy = searchParams.get('ordem') || 'recentes';
    const minPrice = searchParams.get('min');
    const maxPrice = searchParams.get('max');

    // Obter locale do cookie ou usar 'pt' como padr√£o
    const locale = request.cookies.get('NEXT_LOCALE')?.value || 'pt';

    // Montar query base
    const whereClauses = [];

    // Filtro: apenas produtos ativos
    whereClauses.push(eq(products.isActive, true));

    if (featured) {
      whereClauses.push(eq(products.isFeatured, true));
    }

    // üî• OTIMIZA√á√ÉO: Busca simplificada (sem m√∫ltiplas queries)
    if (searchQuery && searchQuery.trim()) {
      const searchTerm = `%${searchQuery.trim()}%`;
      whereClauses.push(
        or(
          ilike(products.name, searchTerm),
          ilike(products.description, searchTerm),
          ilike(products.shortDescription, searchTerm)
        )
      );
    }

    // Filtro por categoria
    if (categorySlug && categorySlug !== 'todas') {
      const categoryResult = await db
        .select({ id: categories.id })
        .from(categories)
        .where(eq(categories.slug, categorySlug))
        .limit(1);

      if (categoryResult.length > 0) {
        const categoryId = categoryResult[0].id;
        const subcategories = await db
          .select({ id: categories.id })
          .from(categories)
          .where(eq(categories.parentId, categoryId));

        const categoryIds = [categoryId, ...subcategories.map(sub => sub.id)];
        whereClauses.push(inArray(products.categoryId, categoryIds));
      }
    }

    const whereClause = whereClauses.length > 0 
      ? (whereClauses.length === 1 ? whereClauses[0] : and(...whereClauses))
      : undefined;

    // üî• OTIMIZA√á√ÉO CR√çTICA: Contar ANTES de buscar dados completos
    const [{ count: totalCount }] = await db
      .select({ count: sql<number>`count(*)` })
      .from(products)
      .where(whereClause);

    // Se n√£o h√° resultados, retornar imediatamente
    if (totalCount === 0) {
      return NextResponse.json({
        products: [],
        pagination: {
          total: 0,
          limit,
          offset: 0,
          hasMore: false,
        },
      });
    }

    // Definir ordena√ß√£o
    let orderByClause;
    switch (sortBy) {
      case 'antigos':
        orderByClause = asc(products.createdAt);
        break;
      case 'nome-asc':
        orderByClause = asc(products.name);
        break;
      case 'nome-desc':
        orderByClause = desc(products.name);
        break;
      default:
        orderByClause = desc(products.createdAt);
        break;
    }

    // üî• OTIMIZA√á√ÉO: Buscar produtos COM pagina√ß√£o ANTES de buscar relacionamentos
    const dbProductsRaw = await db
      .select({
        product: products,
        translation: productI18n,
      })
      .from(products)
      .leftJoin(
        productI18n,
        and(eq(productI18n.productId, products.id), eq(productI18n.locale, locale))
      )
      .where(whereClause)
      .orderBy(orderByClause)
      .limit(limit)
      .offset(offset);

    // Usar dados traduzidos quando dispon√≠veis
    const dbProducts = dbProductsRaw.map(({ product, translation }) => ({
      ...product,
      name: translation?.name || product.name,
      description: translation?.description && translation.description.trim() !== ''
        ? translation.description
        : product.description || '',
      shortDescription: translation?.shortDescription || product.shortDescription,
    }));

    const productIds = dbProducts.map(p => p.id);

    // üî• OTIMIZA√á√ÉO: SINGLE QUERY para buscar varia√ß√µes COM pre√ßo m√≠nimo J√Å CALCULADO
    const variationsWithMinPrice = await db
      .select({
        productId: productVariations.productId,
        minPrice: sql<number>`MIN(CAST(${productVariations.price} AS DECIMAL))`,
        hasVariations: sql<boolean>`COUNT(*) > 0`,
      })
      .from(productVariations)
      .where(
        and(
          inArray(productVariations.productId, productIds),
          eq(productVariations.isActive, true)
        )
      )
      .groupBy(productVariations.productId);

    const minPricesMap = new Map(
      variationsWithMinPrice.map(v => [v.productId!, v.minPrice])
    );

    // üî• OTIMIZA√á√ÉO: Buscar APENAS imagens principais (n√£o todas as imagens)
    const mainImages = await db
      .select()
      .from(productImages)
      .where(
        and(
          inArray(productImages.productId, productIds),
          or(eq(productImages.isMain, true), sql`${productImages.sortOrder} = 0`)
        )
      );

    const mainImagesMap = new Map(
      mainImages.map(img => [img.productId!, img])
    );

    // üî• OTIMIZA√á√ÉO: Buscar categorias de uma vez
    const categoryIds = dbProducts.map(p => p.categoryId).filter((id): id is string => !!id);
    const categoriesMap: Record<string, { id: string; name: string; slug: string }> = {};
    
    if (categoryIds.length > 0) {
      const catsRaw = await db
        .select({
          category: categories,
          translation: categoryI18n,
        })
        .from(categories)
        .leftJoin(
          categoryI18n,
          and(eq(categoryI18n.categoryId, categories.id), eq(categoryI18n.locale, locale))
        )
        .where(inArray(categories.id, categoryIds));

      catsRaw.forEach(({ category, translation }) => {
        categoriesMap[category.id] = {
          id: category.id,
          name: translation?.name || category.name,
          slug: translation?.slug || category.slug,
        };
      });
    }

    // üî• OTIMIZA√á√ÉO: Montar resposta SEM buscar TODAS as varia√ß√µes/atributos
    let productsOut = dbProducts.map(p => {
      const minPrice = minPricesMap.get(p.id) || 0;
      const mainImageObj = mainImagesMap.get(p.id);

      return {
        id: p.id,
        name: p.name,
        slug: p.slug,
        description: p.description,
        shortDescription: p.shortDescription,
        price: minPrice,
        originalPrice: minPrice, // üî• TODO: Buscar promo√ß√µes em batch depois
        hasPromotion: false,
        priceDisplay: `R$ ${minPrice.toFixed(2).replace('.', ',')}`,
        categoryId: p.categoryId,
        category: p.categoryId ? categoriesMap[p.categoryId] || null : null,
        isFeatured: p.isFeatured,
        createdAt: p.createdAt,
        variations: [], // üî• N√£o buscar varia√ß√µes detalhadas aqui
        mainImage: mainImageObj
          ? {
              data: mainImageObj.url,
              alt: mainImageObj.alt || p.name,
            }
          : null,
        images: mainImageObj ? [{
          data: mainImageObj.url,
          alt: mainImageObj.alt || p.name,
        }] : [],
      };
    });

    // Filtrar por faixa de pre√ßo
    if (minPrice) {
      productsOut = productsOut.filter(p => p.price >= Number(minPrice));
    }
    if (maxPrice) {
      productsOut = productsOut.filter(p => p.price <= Number(maxPrice));
    }

    // Ordenar por pre√ßo se necess√°rio
    if (sortBy === 'preco-asc') {
      productsOut.sort((a, b) => a.price - b.price);
    } else if (sortBy === 'preco-desc') {
      productsOut.sort((a, b) => b.price - a.price);
    }

    return NextResponse.json(
      {
        products: productsOut,
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + limit < totalCount,
        },
      },
      {
        headers: {
          // üî• Cache MUITO mais longo
          'Cache-Control': 'public, s-maxage=7200, stale-while-revalidate=14400',
        },
      }
    );
  } catch (error) {
    console.error('Erro na API de produtos:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
